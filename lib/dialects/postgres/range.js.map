{"version":3,"sources":["../../../../sequelize-es6/lib/dialects/postgres/range.js"],"names":["_","require","stringifyRangeBound","bound","Infinity","toString","toLowerCase","JSON","stringify","parseRangeBound","parseType","data","isArray","Error","length","hasOwnProperty","inclusive","each","value","index","isObject","lowerBound","upperBound","exports","parse","parser","empty","result","substring","split","map"],"mappings":"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","file":"range.js","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  } else if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  } else {\n    return JSON.stringify(bound);\n  }\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  } else if (bound === 'infinity') {\n    return Infinity;\n  } else if (bound === '-infinity') {\n    return -Infinity;\n  } else {\n    return parseType(bound);\n  }\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!_.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (data.hasOwnProperty('inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (value.hasOwnProperty('inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (value.hasOwnProperty('value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return (data.inclusive[0] ? '[' : '(') + lowerBound + ',' + upperBound + (data.inclusive[1] ? ']' : ')');\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    const empty = [];\n    empty.inclusive = [];\n    return empty;\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map(value => parseRangeBound(value, parser));\n\n  result.inclusive = [value[0] === '[', value[value.length - 1] === ']'];\n\n  return result;\n}\nexports.parse = parse;\n"]}